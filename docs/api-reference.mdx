---
title: 'API Reference'
description: 'Detailed documentation of the Counting Reward Machines API'
---

# API Reference

## Core Classes

### CountingRewardMachine

The base class for defining counting reward machines.

```python
class CountingRewardMachine:
    def __init__(self):
        """Initialize the CRM with states and transitions."""
        pass

    def step(self, labels: tuple, counters: dict) -> tuple:
        """
        Process a step in the CRM.

        Args:
            labels: Tuple of abstract labels
            counters: Dictionary of counter values

        Returns:
            tuple: (next_state, reward)
        """
        pass
```

### LabellingFunction

Base class for defining labelling functions.

```python
class LabellingFunction:
    def __call__(self, state) -> tuple:
        """
        Convert environment state to abstract labels.

        Args:
            state: Environment state

        Returns:
            tuple: Abstract labels
        """
        pass
```

### CrossProductMDP

Class for creating the cross-product of an environment and CRM.

```python
class CrossProductMDP:
    def __init__(self, ground_env, crm, lf, max_steps=None):
        """
        Create a cross-product MDP.

        Args:
            ground_env: Base environment
            crm: Counting reward machine
            lf: Labelling function
            max_steps: Maximum steps per episode
        """
        pass

    def reset(self) -> tuple:
        """Reset the environment."""
        pass

    def step(self, action) -> tuple:
        """
        Take a step in the environment.

        Args:
            action: Environment action

        Returns:
            tuple: (observation, reward, terminated, truncated, info)
        """
        pass
```

## Example Implementation

### LetterWorldCRM

Example CRM implementation for the Letter World environment.

```python
class LetterWorldCountingRewardMachine(CountingRewardMachine):
    def __init__(self):
        super().__init__()
        self.states = {0, 1, 2, 3}  # Terminal state is 3
        self.initial_state = 0

    def step(self, labels: tuple, counters: dict) -> tuple:
        # Implementation details for letter world transitions
        pass
```

## Utility Functions

### Transition Graph

```python
def compute_crm_transition_graph() -> nx.DiGraph:
    """
    Compute the CRM transition graph.
    
    Returns:
        nx.DiGraph: NetworkX directed graph of CRM transitions
    """
    pass
```

## Next Steps

- See [Examples](/examples) for usage examples
- Check the [Core Concepts](/concepts) for theoretical background
- Follow the [Getting Started](/getting-started) guide for implementation 